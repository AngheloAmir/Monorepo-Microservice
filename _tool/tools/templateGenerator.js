const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

/**
 * 
 * @param {Object} data - The repository data object (name, type, template, description, etc)
 */
async function generateTemplate(data) {
    const { name, type, template: templateName } = data;

    if (!name || !type) {
        throw new Error('Name and Type are required');
    }

    // Resolving root from _tool/tools/templateGenerator.js -> ../../
    const rootDir = path.resolve(__dirname, '../../');
    const targetDir = path.join(rootDir, type, name);

    console.log(`[TemplateGenerator] Creating ${name} in ${type} at ${targetDir}`);

    if (fs.existsSync(targetDir)) {
        throw new Error(`Directory already exists: ${targetDir}`);
    }

    if (templateName && templateName.trim() !== '') {
        // Template source: _tool/tools/../tooldata/<templateName>
        const templateSource = path.join(__dirname, '../tooldata', templateName);
        
        console.log(`[TemplateGenerator] Using template from ${templateSource}`);

        if (!fs.existsSync(templateSource)) {
            throw new Error(`Template source not found: ${templateSource}`);
        }

        // Copy using cp -r for reliability on Linux
        // Create dir first
        await fs.promises.mkdir(targetDir, { recursive: true });
        
        await new Promise((resolve, reject) => {
            // cp -r source/. target/ 
            // copies contents of source to target
            exec(`cp -r "${templateSource}/." "${targetDir}"`, (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    } else {
        console.log(`[TemplateGenerator] No template selected, creating empty with README`);
        // Create directory
        await fs.promises.mkdir(targetDir, { recursive: true });
        // Create README
        await fs.promises.writeFile(
            path.join(targetDir, 'README.md'), 
            `# ${name}\n\nGenerated by Monorepo Microservice Tool.\nType: ${type}`
        );
    }

    // Register into repository.js
    await registerRepository(data);

    return { 
        success: true, 
        message: 'Repository created successfully', 
        path: targetDir 
    };
}

async function registerRepository(data) {
    const repoFilePath = path.resolve(__dirname, '../tooldata/repository.js');
    let content = await fs.promises.readFile(repoFilePath, 'utf8');

    const newEntry = `
        {
            name:        "${data.name || ''}",
            description: "${data.description || ''}",
            icon:        "${data.icon || ''}",
            type:        "${data.type}",
            path:        "../${data.type}/${data.name}",
            branch:      "master",
            devurl:      "${data.devurl || ''}",
            produrl:     "",
            startcmd:    "${data.startcmd || ''}",
            stopcmd:     "${data.stopcmd || ''}",
            buildcmd:    "${data.buildcmd || ''}",
            template:    "${data.template || ''}"
        },`;

    // Find the array for the type, e.g., "service: ["
    // We strictly look for "type: [" pattern.
    const regex = new RegExp(`(${data.type}\\s*:\\s*\\[)`);
    
    if (regex.test(content)) {
        // Insert after the opening bracket
        content = content.replace(regex, `$1${newEntry}`);
        await fs.promises.writeFile(repoFilePath, content, 'utf8');
        console.log(`[TemplateGenerator] Registered ${data.name} in repository.js`);
    } else {
        console.warn(`[TemplateGenerator] Could not find section for type: ${data.type} in repository.js`);
    }
}

module.exports = { generateTemplate };
