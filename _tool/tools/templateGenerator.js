const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

/**
 * 
 * @param {Object} data - The repository data object (name, type, template, description, etc)
 */
async function generateTemplate(data) {
    const { name, type, template: templateName } = data;

    if (!name || !type) {
        throw new Error('Name and Type are required');
    }

    // Resolving root from _tool/tools/templateGenerator.js -> ../../
    const rootDir = path.resolve(__dirname, '../../');
    const targetDir = path.join(rootDir, type, name);

    console.log(`[TemplateGenerator] Creating ${name} in ${type} at ${targetDir}`);

    if (fs.existsSync(targetDir)) {
        throw new Error(`Directory already exists: ${targetDir}`);
    }

    if (templateName && templateName.trim() !== '') {
        // Template source: _tool/tools/../tooldata/<templateName>
        const templateSource = path.join(__dirname, '../tooldata', templateName);
        
        console.log(`[TemplateGenerator] Using template from ${templateSource}`);

        if (!fs.existsSync(templateSource)) {
            throw new Error(`Template source not found: ${templateSource}`);
        }

        // Copy using cp -r for reliability on Linux
        // Create dir first
        await fs.promises.mkdir(targetDir, { recursive: true });
        
        await new Promise((resolve, reject) => {
            // cp -r source/. target/ 
            // copies contents of source to target
            exec(`cp -r "${templateSource}/." "${targetDir}"`, (err) => {
                if (err) reject(err);
                else resolve();
            });
        });

        // Update package.json if it exists (or create if missing but requested? No, usually template has one)
        // actually, we should ensure it has one if we are updating it.
        await updatePackageJson(targetDir, data);

    } else {
        console.log(`[TemplateGenerator] No template selected, creating directory with package.json`);
        // Create directory
        await fs.promises.mkdir(targetDir, { recursive: true });
        
        // Create package.json
        await updatePackageJson(targetDir, data);

        // Create README
        await fs.promises.writeFile(
            path.join(targetDir, 'README.md'), 
            `# ${name}\n\nGenerated by Monorepo Microservice Tool.\nType: ${type}`
        );
    }

    // Register into Workspace.js
    await registerWorkspace(data);

    return { 
        success: true, 
        message: 'Workspace created successfully', 
        path: targetDir 
    };
}

async function registerWorkspace(data) {
    const workspaceFilePath = path.resolve(__dirname, '../tooldata/Workspace.js');
    
    // Invalidate cache to ensure we have latest
    if (require.cache[require.resolve(workspaceFilePath)]) {
        delete require.cache[require.resolve(workspaceFilePath)];
    }
    
    let workspaceData;
    try {
        workspaceData = require(workspaceFilePath);
    } catch (e) {
        console.error('Failed to load Workspace.js for registration', e);
        throw e;
    }

    const newEntry = {
        name:        data.name || '',
        description: data.description || '',
        icon:        data.icon || '',
        type:        data.type,
        path:        `/${data.type}/${data.name}`,
        devurl:      data.devurl || '',
        produrl:     "",
        installcmd:  data.installcmd || '',
        devcmd:      data.devcmd || '',
        startcmd:    data.startcmd || '',
        stopcmd:     data.stopcmd || '',
        buildcmd:    data.buildcmd || '',
        lintcmd:     data.lintcmd || '',
        testcmd:     data.testcmd || '',
        template:    data.template || '',
        giturl:      data.giturl || '',
        gitorigin:   data.gitorigin || 'origin',
        gitbranch:   data.gitbranch || 'master'
    };

    if (workspaceData[data.type]) {
        workspaceData[data.type].push(newEntry);
        
        const content = `/**
 * Workspace Data
 */

const workspace = ${JSON.stringify(workspaceData, null, 4)}

module.exports = workspace;
`;
        await fs.promises.writeFile(workspaceFilePath, content, 'utf8');
        console.log(`[TemplateGenerator] Registered ${data.name} in Workspace.js`);
    } else {
        console.warn(`[TemplateGenerator] Could not find section for type: ${data.type} in Workspace.js`);
    }
}


async function updatePackageJson(targetDir, data) {
    const pkgPath = path.join(targetDir, 'package.json');
    let pkg = {
        name: data.name,
        version: "1.0.0",
        description: data.description || "",
        scripts: {},
        keywords: [],
        author: "",
        license: "ISC"
    };

    if (fs.existsSync(pkgPath)) {
        try {
            const existing = JSON.parse(await fs.promises.readFile(pkgPath, 'utf8'));
            // Merge defaults with existing, giving priority to existing (preserves scripts/deps)
            pkg = { ...pkg, ...existing };
            
            // Enforce overrides from user data
            pkg.name = data.name; 
            if (data.description) pkg.description = data.description;
        } catch (e) {
            console.error('Error reading package.json', e);
        }
    }

    if (!pkg.scripts) pkg.scripts = {};

    // Map fields to scripts
    const scriptMap = {
        'dev': data.devcmd,
        'start': data.startcmd,
        'stop': data.stopcmd,
        'build': data.buildcmd,
        'lint': data.lintcmd,
        'test': data.testcmd
    };

    for (const [key, cmd] of Object.entries(scriptMap)) {
        // Only add if cmd is provided and valid
        if (cmd && cmd.trim() !== '') {
            const trimmed = cmd.trim();
            // Prevent recursive loops
            // 1. Install loop: "install": "npm install"
            if (key === 'install' && trimmed.match(/^npm\s+install/)) {
                continue; 
            }
            
            // 2. npm run loop: "build": "npm run build"
            // Note: matching "npm run key" or "npm run-script key"
            if (trimmed.match(new RegExp(`^npm\\s+(run|run-script)\\s+${key}\\b`))) {
                continue;
            }

            // 3. npm short loop: "test": "npm test" or "start": "npm start"
             if (trimmed.match(new RegExp(`^npm\\s+${key}\\b`))) {
                continue;
            }
            
            pkg.scripts[key] = cmd;
        }
    }

    await fs.promises.writeFile(pkgPath, JSON.stringify(pkg, null, 2));
}

module.exports = { generateTemplate };
