const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

/**
 * 
 * @param {Object} data - The repository data object (name, type, template, description, etc)
 */
async function generateTemplate(data) {
    const { name, type, template: templateName } = data;

    if (!name || !type) {
        throw new Error('Name and Type are required');
    }

    // Resolving root from _tool/tools/templateGenerator.js -> ../../
    const rootDir = path.resolve(__dirname, '../../');
    const targetDir = path.join(rootDir, type, name);

    console.log(`[TemplateGenerator] Creating ${name} in ${type} at ${targetDir}`);

    if (fs.existsSync(targetDir)) {
        throw new Error(`Directory already exists: ${targetDir}`);
    }

    if (templateName && templateName.trim() !== '') {
        // Template source: _tool/tools/../tooldata/<templateName>
        const templateSource = path.join(__dirname, '../tooldata', templateName);
        
        console.log(`[TemplateGenerator] Using template from ${templateSource}`);

        if (!fs.existsSync(templateSource)) {
            throw new Error(`Template source not found: ${templateSource}`);
        }

        // Copy using cp -r for reliability on Linux
        // Create dir first
        await fs.promises.mkdir(targetDir, { recursive: true });
        
        await new Promise((resolve, reject) => {
            // cp -r source/. target/ 
            // copies contents of source to target
            exec(`cp -r "${templateSource}/." "${targetDir}"`, (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    } else {
        console.log(`[TemplateGenerator] No template selected, creating empty with README`);
        // Create directory
        await fs.promises.mkdir(targetDir, { recursive: true });
        // Create README
        await fs.promises.writeFile(
            path.join(targetDir, 'README.md'), 
            `# ${name}\n\nGenerated by Monorepo Microservice Tool.\nType: ${type}`
        );
    }

    // Register into repository.js
    await registerRepository(data);

    return { 
        success: true, 
        message: 'Repository created successfully', 
        path: targetDir 
    };
}

async function registerRepository(data) {
    const repoFilePath = path.resolve(__dirname, '../tooldata/repository.js');
    
    // Invalidate cache to ensure we have latest
    if (require.cache[require.resolve(repoFilePath)]) {
        delete require.cache[require.resolve(repoFilePath)];
    }
    
    let repoData;
    try {
        repoData = require(repoFilePath);
    } catch (e) {
        console.error('Failed to load repository.js for registration', e);
        throw e;
    }

    const newEntry = {
        name:        data.name || '',
        description: data.description || '',
        icon:        data.icon || '',
        type:        data.type,
        path:        `/${data.type}/${data.name}`,
        branch:      "master",
        devurl:      data.devurl || '',
        produrl:     "",
        startcmd:    data.startcmd || '',
        stopcmd:     data.stopcmd || '',
        buildcmd:    data.buildcmd || '',
        template:    data.template || ''
    };

    if (repoData[data.type]) {
        repoData[data.type].push(newEntry);
        
        const content = `/**
 * Repository Data
 */

const repository = ${JSON.stringify(repoData, null, 4)}

module.exports = repository;
`;
        await fs.promises.writeFile(repoFilePath, content, 'utf8');
        console.log(`[TemplateGenerator] Registered ${data.name} in repository.js`);
    } else {
        console.warn(`[TemplateGenerator] Could not find section for type: ${data.type} in repository.js`);
    }
}

module.exports = { generateTemplate };
